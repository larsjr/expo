{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/typed-routes/index.ts"],"names":[],"mappings":";;;;;;AAAA,sDAAyB;AACzB,0DAA6B;AAE7B,yCAA2D;AAC3D,qCAAiC;AACjC,0CAAoD;AAEpD,SAAgB,iCAAiC,CAAC,SAAiB;IACjE,MAAM,UAAU,GAAG,IAAI,GAAG,CAAC,UAAG,CAAC,IAAI,EAAE,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,IAAA,gCAAqB,EAAC,GAAG,CAAC,CAAC,CAAC,CAAC;IAEnF,OAAO,KAAK,UAAU,QAAQ,CAAC,EAAE,QAAQ,EAAE,IAAI,EAAsC;QACnF,IAAI,gBAAgB,GAAG,KAAK,CAAC;QAE7B,IAAI,IAAI,KAAK,QAAQ,EAAE;YACrB,IAAI,UAAU,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE;gBAC5B,UAAU,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;gBAC5B,gBAAgB,GAAG,IAAI,CAAC;aACzB;SACF;aAAM,IAAI,IAAI,KAAK,KAAK,EAAE;YACzB,gBAAgB,GAAG,IAAA,gCAAqB,EAAC,QAAQ,CAAC,CAAC;SACpD;aAAM;YACL,gBAAgB,GAAG,UAAU,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;SAC7C;QAED,IAAI,gBAAgB,EAAE;YACpB,IAAA,gCAAwB,EAAC,SAAS,CAAC,CAAC;SACrC;IACH,CAAC,CAAC;AACJ,CAAC;AArBD,8EAqBC;AAEY,QAAA,wBAAwB,GAAG,QAAQ,CAAC,CAAC,SAAiB,EAAE,EAAE;IACrE,MAAM,IAAI,GAAG,IAAA,wCAA6B,EAAC,UAAG,CAAC,CAAC;IAChD,IAAI,CAAC,IAAI;QAAE,OAAO;IAClB,iBAAE,CAAC,aAAa,CAAC,mBAAI,CAAC,OAAO,CAAC,SAAS,EAAE,eAAe,CAAC,EAAE,IAAI,CAAC,CAAC;AACnE,CAAC,EAAE,GAAG,CAAC,CAAC;AAER;;;GAGG;AACH,SAAS,QAAQ,CAAoC,EAAK,EAAE,QAAgB;IAC1E,IAAI,OAAO,CAAC;IACZ,IAAI,cAAc,GAAG,KAAK,CAAC;IAC3B,OAAO,SAAS,GAAG,CAAC,GAAG,IAAmB;QACxC,IAAI,OAAO,EAAE;YACX,cAAc,GAAG,IAAI,CAAC;SACvB;aAAM;YACL,EAAE,CAAC,GAAG,IAAI,CAAC,CAAC;YACZ,OAAO,GAAG,UAAU,CAAC,GAAG,EAAE;gBACxB,OAAO,GAAG,IAAI,CAAC,CAAC,gDAAgD;gBAChE,IAAI,cAAc,EAAE;oBAClB,GAAG,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,0BAA0B;iBACzC;YACH,CAAC,EAAE,QAAQ,CAAC,CAAC;SACd;IACH,CAAC,CAAC;AACJ,CAAC","sourcesContent":["import fs from 'node:fs';\nimport path from 'node:path';\n\nimport { getTypedRoutesDeclarationFile } from './generate';\nimport { ctx } from '../../_ctx';\nimport { isTypedRoutesFilename } from '../matchers';\n\nexport function getGenerateTypeDeclarationHandler(outputDir: string) {\n  const routeFiles = new Set(ctx.keys().filter((key) => isTypedRoutesFilename(key)));\n\n  return async function callback({ filePath, type }: { filePath: string; type: string }) {\n    let shouldRegenerate = false;\n\n    if (type === 'delete') {\n      if (routeFiles.has(filePath)) {\n        routeFiles.delete(filePath);\n        shouldRegenerate = true;\n      }\n    } else if (type === 'add') {\n      shouldRegenerate = isTypedRoutesFilename(filePath);\n    } else {\n      shouldRegenerate = routeFiles.has(filePath);\n    }\n\n    if (shouldRegenerate) {\n      generateTypeDeclarations(outputDir);\n    }\n  };\n}\n\nexport const generateTypeDeclarations = throttle((outputDir: string) => {\n  const file = getTypedRoutesDeclarationFile(ctx);\n  if (!file) return;\n  fs.writeFileSync(path.resolve(outputDir, './router.d.ts'), file);\n}, 100);\n\n/**\n * Throttles a function to only run once every `internal` milliseconds.\n * If called while waiting, it will run again after the timer has elapsed.\n */\nfunction throttle<T extends (...args: any[]) => any>(fn: T, interval: number) {\n  let timerId;\n  let shouldRunAgain = false;\n  return function run(...args: Parameters<T>) {\n    if (timerId) {\n      shouldRunAgain = true;\n    } else {\n      fn(...args);\n      timerId = setTimeout(() => {\n        timerId = null; // reset the timer so next call will be executed\n        if (shouldRunAgain) {\n          run(...args); // call the function again\n        }\n      }, interval);\n    }\n  };\n}\n"]}